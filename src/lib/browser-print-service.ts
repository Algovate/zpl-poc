/**
 * BrowserPrint Service - Handles browser-based printing functionality
 * Supports both direct browser printing and ZPL command generation
 */

export interface BrowserPrintConfig {
  printerName?: string
  copies?: number
  orientation?: 'portrait' | 'landscape'
  paperSize?: 'A4' | 'A5' | 'letter' | 'label'
  margins?: {
    top: number
    right: number
    bottom: number
    left: number
  }
}

export interface PrintJob {
  id: string
  content: string
  type: 'html' | 'zpl' | 'text'
  config: BrowserPrintConfig
  timestamp: Date
  status: 'pending' | 'printing' | 'completed' | 'failed'
}

export class BrowserPrintService {
  private printQueue: PrintJob[] = []
  private isPrinting = false

  /**
   * Print HTML content directly to browser
   */
  async printHTML(html: string, config: BrowserPrintConfig = {}): Promise<boolean> {
    try {
      const printWindow = window.open('', '_blank')
      if (!printWindow) {
        throw new Error('Unable to open print window')
      }

      // Set up the print window content
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Print Job</title>
          <style>
            body { 
              margin: ${config.margins?.top || 0}px ${config.margins?.right || 0}px ${config.margins?.bottom || 0}px ${config.margins?.left || 0}px;
              font-family: Arial, sans-serif;
            }
            @media print {
              @page {
                size: ${config.paperSize || 'A4'};
                margin: ${config.margins?.top || 0}px ${config.margins?.right || 0}px ${config.margins?.bottom || 0}px ${config.margins?.left || 0}px;
              }
            }
          </style>
        </head>
        <body>
          ${html}
        </body>
        </html>
      `)

      printWindow.document.close()

      // Wait for content to load
      await new Promise(resolve => setTimeout(resolve, 500))

      // Trigger print dialog
      printWindow.print()

      // Close window after printing
      setTimeout(() => {
        printWindow.close()
      }, 1000)

      return true
    } catch (error) {
      console.error('HTML print failed:', error)
      return false
    }
  }

  /**
   * Generate ZPL commands for label printing
   */
  generateZPL(content: { title?: string; description?: string }, config: BrowserPrintConfig = {}): string {
    const zpl = `^XA
^MMT
^PW800
^LL600
^LS0
^BY3,3,50
^FO50,50^ADN,36,20^FD${content.title || 'Test Print'}^FS
^FO50,100^ADN,24,12^FD${content.description || 'Generated by BrowserPrint Service'}^FS
^FO50,150^ADN,18,9^FD${new Date().toLocaleString()}^FS
^XZ`

    return zpl
  }

  /**
   * Send ZPL to printer via network (simulation)
   */
  async sendZPLToPrinter(zpl: string, printerConfig: { host: string; port: number; name: string }): Promise<boolean> {
    try {
      console.log('Sending ZPL to printer:', printerConfig)
      console.log('ZPL Content:', zpl)

      // Simulate network delay
      await new Promise(resolve => setTimeout(resolve, 1000))

      // Simulate success/failure (90% success rate)
      const success = Math.random() > 0.1

      if (success) {
        console.log('ZPL sent successfully to printer')
      } else {
        console.error('Failed to send ZPL to printer')
      }

      return success
    } catch (error) {
      console.error('ZPL printing error:', error)
      return false
    }
  }

  /**
   * Print text content
   */
  async printText(text: string, config: BrowserPrintConfig = {}): Promise<boolean> {
    const html = `
      <div style="font-family: monospace; white-space: pre-wrap; padding: 20px;">
        ${text}
      </div>
    `
    return this.printHTML(html, config)
  }

  /**
   * Print ZPL preview as HTML
   */
  async printZPLPreview(zpl: string, config: BrowserPrintConfig = {}): Promise<boolean> {
    const html = `
      <div style="font-family: monospace; background: #f5f5f5; padding: 20px; border: 1px solid #ddd;">
        <h3>ZPL Command Preview</h3>
        <pre style="background: #000; color: #0f0; padding: 15px; border-radius: 5px; overflow-x: auto;">${zpl}</pre>
        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>
      </div>
    `
    return this.printHTML(html, config)
  }

  /**
   * Get available printers (simulation)
   */
  async getAvailablePrinters(): Promise<string[]> {
    // Simulate network delay
    await new Promise(resolve => setTimeout(resolve, 500))

    return [
      'Zebra ZD420',
      'Zebra ZD620',
      'HP LaserJet Pro',
      'Canon PIXMA',
      'Brother QL-800',
      'Browser Default Printer'
    ]
  }

  /**
   * Test printer connection
   */
  async testPrinterConnection(printerName: string): Promise<boolean> {
    try {
      console.log(`Testing connection to printer: ${printerName}`)
      
      // Simulate connection test
      await new Promise(resolve => setTimeout(resolve, 1000))
      
      // Simulate 95% success rate
      const success = Math.random() > 0.05
      
      if (success) {
        console.log(`Printer ${printerName} is available`)
      } else {
        console.error(`Printer ${printerName} is not available`)
      }
      
      return success
    } catch (error) {
      console.error(`Printer test failed for ${printerName}:`, error)
      return false
    }
  }

  /**
   * Get print job status
   */
  getPrintJobStatus(jobId: string): PrintJob | null {
    return this.printQueue.find(job => job.id === jobId) || null
  }

  /**
   * Get all print jobs
   */
  getAllPrintJobs(): PrintJob[] {
    return [...this.printQueue]
  }

  /**
   * Clear print queue
   */
  clearPrintQueue(): void {
    this.printQueue = []
  }

  /**
   * Add job to print queue
   */
  private addToQueue(job: PrintJob): void {
    this.printQueue.push(job)
  }

  /**
   * Update job status
   */
  private updateJobStatus(jobId: string, status: PrintJob['status']): void {
    const job = this.printQueue.find(j => j.id === jobId)
    if (job) {
      job.status = status
    }
  }
}

// Export singleton instance
export const browserPrintService = new BrowserPrintService()
